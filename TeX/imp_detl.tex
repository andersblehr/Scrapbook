%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Latex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% imp_detl.tex --- 
%%% Author          : blehr
%%% Created On      : Sun Apr 11 18:40:52 1993
%%% Last Modified By: blehr
%%% Last Modified On: Mon Apr 12 16:47:48 1993
%%% RCS revision    : $Revision: 1.2 $ $Locker:  $
%%% Status          : In writing....
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation Details}
\label{implem:details}

As pointed out in Section~\ref{intro:env}, {\octopus} has been
implemented solely in Pascal, using Borland's Turbo-Pascal 6.0.  Three
issues demand further elaboration, these being the format of the
images that are fed to the algorithm, presented in
Section~\ref{implem:details:format}; parameter initialization,
discussed in Section~\ref{implem:details:param}; and lastly,
implementation of the plausibility areas presented in
Section~\ref{algo:seek:strategy}, discussed in
Section~\ref{implem:details:plausible}.

\subsection{Image Format}
\label{implem:details:format}

So far, the format of the images supplied to the current
implementation of {\octopus} has been given no attention.  In the
final implementation, they are to be accessed from the memory
device(s) of the frame-grabber to be employed by the complete
eye-tracking system.  Temporarily, however, they have to be stored in
files conforming to a specific format.  The name of the file which is
to be supplied to {\octopus} is given as a command line
parameter\footnote{The file name has to be the last command line
  parameter supplied; cf.\ Section~\ref{implem:sources:eyepos}.}.
Obviously, the current implementation of {\octopus} is only capable of
handling one image at the time.

The format of the image file is very simple.  The two first bytes of
the file contain the horizontal resolution $M$ of the $M\times N$
image (cf.\ footnote~\ref{pg:notsquare} on p.~\pageref{pg:notsquare}),
and the two next bytes contain the vertical resolution $N$ of the
image.  All consequent bytes are read as gray levels for pixels in the
image.  Note that the highest gray level in the current implementation
is set to be 63.  Note also that the image files are not compressed in
any way.

\subsection{Parameter Initialization}
\label{implem:details:param}

As was indicated in Section~\ref{algo:future:calibrate}, there are
three different methods of assigning values to the different
parameters employed by {\octopus}.  Firstly, they are assigned default
values through typed constants.  The default values can be overridden
by defining new default values in an initialization file.  The name of
the initialization file is {\tt \_search.rc}.  Lastly, the values
assigned by either of these two methods are overridden by command line
parameters.  Here the focus will be on the format of the
initialization file.  See the comments in the source listing in
Section~\ref{implem:sources:eyepos} for a description of valid command
line parameters.

A sample initialization file is shown in Fig.~\ref{fig:initfile}.  As
is seen, each line of the file has the form

\begin{center}
  $\langle${\sl Variable name\/}$\rangle$ $\langle${\sl Assigned
    value\/}$\rangle$.
\end{center}

\noindent {\sl Variable name\/} has to be the exact same name which is
used in the source, and {\sl Assigned value\/} is interpreted as a
{\tt real} number.  Evidently, the variable names used in the
implementation do not correspond very well to the notation introduced
and used in this paper.  See the comments in the source listings in
Section~\ref{implem:sources} for the correspondence between source
variable names and parameter names used in the text.  Note that a
random number of empty lines can occur in the initialization file and
that end-of-line comments start with a {\tt \%}-character.

As mentioned, the name of the initialization file is {\tt
  \_search.rc}.  The current implementation looks for a file with this
name in the directory returned by the auxiliary function {\tt
  homeDirectory}\footnote{{\tt homeDirectory} is currently implemented
  in {\tt auxil.pas} (not listed) and the value returned is {\tt
    /user/blehr/}.}.

\begin{figure}[tb]
  \begin{verbatim}
                  % _search.rc - initialization file for OCTOPUS.

                  lakeLevel                   18    % T_{l}
                  sobelThreshold               5    % T_{e}
                  wetFraction                  0.8  % T_{s}

                  minPupilRadiusFraction      10    % r_{p_{min}}
                  octopusRadiusFraction        8    % r_{d}

                  nIterations                  1
    \end{verbatim}
  \caption{\label{fig:initfile}A sample initialization file.}
\end{figure}

\subsection{Implementing the Plausibility Areas}
\label{implem:details:plausible}

The plausibility areas described in Section~\ref{algo:seek:strategy}
are basically implemented using a three-element array indexing a
second array containing the candidate pixels.  Element $i$, $1\leq
i\leq 3$, of the three-element array contains an integer denoting the
number $n_{i}$ of candidate pixels contained in plausibility area $i$.
The second array contains all candidate pixels in {\SS}.  Recall that
plausibility area 1 is a proper subset of plausibility area 2 and that
plausibility area 2 is a proper subset of plausibility area 3, the
latter corresponding to {\SS} itself\footnote{Given that the number of
  plausibility areas is 3, cf.\ Section~\ref{algo:seek:strategy}.}.
The array is ordered so that the members of plausibility area 1 are
contained in the $n_{1}$ first elements, the members of plausibility
area 2 in the $n_{2}$ first elements and the members of plausibility
area 3 in the $n_{3}$ first elements.  Each element of the array
contains the coordinate pair of a candidate pixel and a boolean flag
{\sl visited\/} telling whether or not the candidate pixel already has
been used as starting pixel.  

At the outset of the search procedure, the priority level $p$ is
assigned value 1, which is used to index the three-element array.  The
value thus obtained is $n_{1}$, the number of elements in plausibility
area 1, and the Turbo-Pascal function {\tt random} is called with
$n_{1}$ as parameter, returning a value between 0 and $n_{1}-1$.  This
value is used to index the second array, and since the $n_{1}$ first
elements of the array are the members of plausibility area 1, the
point thus obtained belongs to plausibility area 1.  If the point is
already marked visited, a new random number is generated, and this
process is repeated until a point is found which has not been visited.
It is then marked visited and used as starting pixel.  A counter is
incremented each time a starting pixel has been selected.  If this
counter reaches $n_{1}$, the priority level is incremented, thus
enabling points belonging to plausibility area 2 to be selected.  Note
that when the priority level is incremented, all candidate pixels
belonging to plausibility area 1 have been marked visited, so the only
members of plausibility area 2 that can be selected are those not
belonging to plausibility area 1.  This process is repeated until a
pupil point is found or there are no more unvisited elements in the
array, which corresponds to every candidate pixel of {\SS} having been
used as starting pixel without success.  In the latter case, the pupil
could not be found in the image, and the value {\tt false} is
returned.  The procedure is illustrated in Fig.~\ref{fig:implem}.

\insertpdfwidth{implem}{\label{fig:implem}The principle behind the
  implementation of the plausibility areas described in
  Section~\protect\ref{algo:seek:strategy}.  $p$ denotes the priority
  level and $n_{i}$, $1\leq i\leq 3$, the number of candidate pixels
  contained in plausibility area $i$.}{0.8}
